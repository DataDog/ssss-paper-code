use std::{fmt, hash::Hash, iter::repeat, marker::PhantomData};

use ahash::RandomState;

use crate::{dist::Distribution, util::make_hash, CardinalitySketch};

#[derive(Clone)]
pub struct HyperLogLog<I> {
    d: usize,
    d_log2: usize,
    registers: Vec<u8>,
    seeds: [RandomState; 2],
    item_type: PhantomData<I>,
}

impl<I> HyperLogLog<I> {
    pub fn new(d: usize) -> Self {
        Self::with_seeds(d, Default::default())
    }

    pub fn with_seeds(d: usize, seeds: [RandomState; 2]) -> Self {
        assert!(d & (d - 1) == 0); // non-zero power of 2
        Self {
            d,
            d_log2: d.trailing_zeros().try_into().unwrap(),
            registers: repeat(0).take(d).collect(),
            seeds,
            item_type: PhantomData,
        }
    }
}

impl<I> CardinalitySketch for HyperLogLog<I>
where
    I: Hash,
{
    type Item = I;

    fn insert(&mut self, item: Self::Item) {
        let z = u8::try_from(make_hash(&self.seeds[1], &item).trailing_zeros()).unwrap() + 1; // TODO: +1?
        let r: usize = make_hash(&self.seeds[0], &item) as usize & (self.d - 1);

        let register = self.registers.get_mut(r).unwrap();
        *register = z.max(*register);
    }

    fn cardinality(&self) -> usize {
        // TODO: no need to compute the Distribution.
        ((self.d as f64 * alpha(self.d))
            / self
                .registers
                .iter()
                .copied()
                .map(From::from)
                .collect::<Distribution>()
                .pmf_iter()
                .map(|(c, p)| p * 2.0_f64.powi(-i32::try_from(c).unwrap()))
                .sum::<f64>()) as usize
    }
}

impl<I> fmt::Debug for HyperLogLog<I> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("HyperLogLog")
            .field("d", &self.d)
            .field("d_log2", &self.d_log2)
            .field("item_type", &self.item_type)
            .finish()
    }
}

pub const fn alpha(d: usize) -> f64 {
    assert!(d & (d - 1) == 0); // non-zero power of 2
    match d {
        1 | 2 | 4 | 8 => panic!(),
        16 => 0.673,
        32 => 0.697,
        64 => 0.709,
        128 => 0.715,
        256 => 0.718,
        512 => 0.720,
        _ => 0.721,
    }
}

#[cfg(test)]
mod tests {
    use crate::CardinalitySketch;

    use super::HyperLogLog;
    use ahash::RandomState;
    use proptest::prelude::*;

    #[derive(Clone, Debug)]
    struct TestCase {
        cardinality: u64,
        sketch: HyperLogLog<u64>,
    }

    fn test_cases() -> impl Strategy<Value = TestCase> {
        let test_cases = vec![(6_000, 3), (10_000_000, 7)];

        let sketches = test_cases
            .into_iter()
            .map(|(cardinality, num_inserts_per_item)| {
                let seeds = [
                    RandomState::with_seeds(0, 1, 2, 3),
                    RandomState::with_seeds(4, 5, 6, 7),
                ];
                let mut sketch = HyperLogLog::with_seeds(1024, seeds);
                (0..num_inserts_per_item)
                    .flat_map(|_| 0..cardinality)
                    .for_each(|item| sketch.insert(item));
                TestCase {
                    cardinality,
                    sketch,
                }
            })
            .map(Just);

        proptest::strategy::Union::new(sketches)
    }

    #[test]
    fn it_estimates_cardinality() {
        proptest!(ProptestConfig::with_cases(16), |(test_case in test_cases())| {
            prop_assume!(test_case.cardinality > 0); // FIXME
            let cardinality = test_case.sketch.cardinality();
            prop_assert!((cardinality as f64 - test_case.cardinality as f64).abs() / test_case.cardinality as f64 <= 5e-2);
        })
    }
}
